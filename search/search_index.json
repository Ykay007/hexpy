{
    "docs": [
        {
            "location": "/",
            "text": "A Python Client for the Crimson Hexagon API\n\n\nhexpy\n is a simple python package for working with the Crimson Hexagon API\n\n\nWhy use this client?\n\n\n\n\nEasily and securely manage account authentication.\n\n\nAutomatically abide by Crimson Hexagon's rate limits.\n\n\nAutomatically convert python data to/from JSON strings.\n\n\nAutomatically check requests success.\n\n\nMake it easy to do common tasks like exporting and uploading content.\n\n\nEasily create shell scripts to work with API data.\n\n\n\n\nRequirements\n\n\nhexpy\n is compatible with Python 3.5 and higher\n\n\nInstallation\n\n\n\n\n\nTo install the latest version:\n\n\n$ git clone https://github.com/sullivancolin/hexpy.git\n$ pip install hexpy/\n\n\n\n\nProject Homepage\n\n\nVisit \nGithub\n project page for full source code.\n\n\nQuick Start\n\n\n>>> from hexpy import HexpySession, MonitorAPI\n>>> session = HexpySession(username=\"user@email.com\", password=\"crimson_login\")\n>>> monitor_results_client=MonitorAPI(session)\n>>> monitor_results_client.details(monitor_id)\n{'categories': [{'hidden': False,\n   'id': 6054759055,\n   'name': 'Basic Positive',\n   'sortOrder': 100,\n   'status': 'red',\n   'trainingDocs': 0},\n  {'hidden': False,\n   'id': 6054759059,\n   'name': 'Basic Neutral',\n   'sortOrder': 101,\n   'status': 'red',\n   'trainingDocs': 0},\n  {'hidden': False,\n   'id': 6054759051,\n   'name': 'Basic Negative',\n   'sortOrder': 102,\n   ...\n\n>>> session.close()",
            "title": "Home"
        },
        {
            "location": "/#a-python-client-for-the-crimson-hexagon-api",
            "text": "hexpy  is a simple python package for working with the Crimson Hexagon API",
            "title": "A Python Client for the Crimson Hexagon API"
        },
        {
            "location": "/#why-use-this-client",
            "text": "Easily and securely manage account authentication.  Automatically abide by Crimson Hexagon's rate limits.  Automatically convert python data to/from JSON strings.  Automatically check requests success.  Make it easy to do common tasks like exporting and uploading content.  Easily create shell scripts to work with API data.",
            "title": "Why use this client?"
        },
        {
            "location": "/#requirements",
            "text": "hexpy  is compatible with Python 3.5 and higher",
            "title": "Requirements"
        },
        {
            "location": "/#installation",
            "text": "To install the latest version:  $ git clone https://github.com/sullivancolin/hexpy.git\n$ pip install hexpy/",
            "title": "Installation"
        },
        {
            "location": "/#project-homepage",
            "text": "Visit  Github  project page for full source code.",
            "title": "Project Homepage"
        },
        {
            "location": "/#quick-start",
            "text": ">>> from hexpy import HexpySession, MonitorAPI\n>>> session = HexpySession(username=\"user@email.com\", password=\"crimson_login\")\n>>> monitor_results_client=MonitorAPI(session)\n>>> monitor_results_client.details(monitor_id)\n{'categories': [{'hidden': False,\n   'id': 6054759055,\n   'name': 'Basic Positive',\n   'sortOrder': 100,\n   'status': 'red',\n   'trainingDocs': 0},\n  {'hidden': False,\n   'id': 6054759059,\n   'name': 'Basic Neutral',\n   'sortOrder': 101,\n   'status': 'red',\n   'trainingDocs': 0},\n  {'hidden': False,\n   'id': 6054759051,\n   'name': 'Basic Negative',\n   'sortOrder': 102,\n   ...\n\n>>> session.close()",
            "title": "Quick Start"
        },
        {
            "location": "/Sessions/",
            "text": "Sessions\n\n\nCreating a session and generating a token for API requests.\n\n\nInstantiate using token, or username. Optionally include password, or enter it at the prompt.\n\n\n>>> from hexpy import HexpySession\n>>> session = HexpySession(username=\"username@gmail.com\", password=\"secretpassword\")\n>>> session.save_token()\n\n\n\n\nor\n\n\n>>> session = HexpySession(username=\"username@email.com\")\nEnter password: *********\n>>> session.save_token()\n\n\n\n\nor\n\n\n>>> session = HexpySession(token=\"previously_saved_token\")\n\n\n\n\nCreate instance by loading token from file.  Default is \n~/.hexpy/credentials.json\n\n\n>>> session = HexpySession.load_auth_from_file()\n\n\n\n\nCreate instance with context manager to close TCP session automatically when finished\n\n\n>>> with HexpySession.load_auth_from_file() as session:\n...:     client = MonitorAPI(session)\n...:     # use client to call API multiple times with same session\n\n>>> # session TCP connection is closed until next call to API\n\n\n\n\nMethods\n\n\nget_token\n\n\nget_token(username, password, no_expiration=False)\n\n\n\n\nRequest authorization token.\n\n\nArguments\n\n\n\n\nusername: account username.\n\n\npassword: account password.\n\n\nno_expiration: True/False token with 24 expiration.\n\n\n\n\nsave_token\n\n\nsave_token(path=None)\n\n\n\n\nSave authorization token.\n\n\nArguments\n\n\n\n\npath: String, path to store credentials. default is \n~/.hexpy/credentials.json\n\n\n\n\nload_auth_from_file\n\n\nload_auth_from_file(path=None)\n\n\n\n\nInstantiate class from previously saved credentials file.\n\n\nArguments\n\n\n\n\npath: String, path to store credentials. default is \n~/.hexpy/credentials.json\n\n\n\n\nclose\n\n\nclose()\n\n\n\n\nClose persisted connection to API server.",
            "title": "Sessions"
        },
        {
            "location": "/Sessions/#sessions",
            "text": "",
            "title": "Sessions"
        },
        {
            "location": "/Sessions/#creating-a-session-and-generating-a-token-for-api-requests",
            "text": "Instantiate using token, or username. Optionally include password, or enter it at the prompt.  >>> from hexpy import HexpySession\n>>> session = HexpySession(username=\"username@gmail.com\", password=\"secretpassword\")\n>>> session.save_token()  or  >>> session = HexpySession(username=\"username@email.com\")\nEnter password: *********\n>>> session.save_token()  or  >>> session = HexpySession(token=\"previously_saved_token\")  Create instance by loading token from file.  Default is  ~/.hexpy/credentials.json  >>> session = HexpySession.load_auth_from_file()  Create instance with context manager to close TCP session automatically when finished  >>> with HexpySession.load_auth_from_file() as session:\n...:     client = MonitorAPI(session)\n...:     # use client to call API multiple times with same session\n\n>>> # session TCP connection is closed until next call to API",
            "title": "Creating a session and generating a token for API requests."
        },
        {
            "location": "/Sessions/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/Sessions/#get_token",
            "text": "get_token(username, password, no_expiration=False)  Request authorization token.",
            "title": "get_token"
        },
        {
            "location": "/Sessions/#arguments",
            "text": "username: account username.  password: account password.  no_expiration: True/False token with 24 expiration.",
            "title": "Arguments"
        },
        {
            "location": "/Sessions/#save_token",
            "text": "save_token(path=None)  Save authorization token.",
            "title": "save_token"
        },
        {
            "location": "/Sessions/#arguments_1",
            "text": "path: String, path to store credentials. default is  ~/.hexpy/credentials.json",
            "title": "Arguments"
        },
        {
            "location": "/Sessions/#load_auth_from_file",
            "text": "load_auth_from_file(path=None)  Instantiate class from previously saved credentials file.",
            "title": "load_auth_from_file"
        },
        {
            "location": "/Sessions/#arguments_2",
            "text": "path: String, path to store credentials. default is  ~/.hexpy/credentials.json",
            "title": "Arguments"
        },
        {
            "location": "/Sessions/#close",
            "text": "close()  Close persisted connection to API server.",
            "title": "close"
        },
        {
            "location": "/Metadata/",
            "text": "Metadata API\n\n\nClass for working with Crimson Hexagon account and analysis metadata.\n\n\nExample usage.\n\n\n>>> from hexpy import HexpySession, MetadataAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> metadata_client = MetadataAPI(session)\n>>> metadata_client.team_list()\n>>> session.close()\n\n\n\n\nMethods\n\n\nteam_list\n\n\nteam_list()\n\n\n\n\nReturn a list of teams accessible to the requesting user.\n\n\nmonitor_list\n\n\nmonitor_list(team_id)\n\n\n\n\nReturns a list of monitors accessible to the requesting or selected user along with metadata related to those monitors.\n\n\nArguments\n\n\n\n\nteam_id: integer id number for a team\n\n\n\n\ngeography\n\n\ngeography()\n\n\n\n\nReturn all the geographical locations that you may use to filter monitor results and to upload documents with location information.\n\n\nstates\n\n\nstates(country)\n\n\n\n\nReturn all the states for a given country that you may use to filter monitor results and to upload documents with location information.\n\n\nArguments\n\n\n\n\ncountry: country code to filter states\n\n\n\n\ncities\n\n\ncities(country)\n\n\n\n\nReturns all the cities or urban areas defined in the given country that you may use to filter monitor results and to upload documents with location information. \n\n\nArguments\n\n\n\n\ncountry: country: country code  to filter states\n\n\n\n\ncountries\n\n\ncountries()\n\n\n\n\nReturns all the countries that you may use to filter monitor results and to upload documents with location information.",
            "title": "Metadata"
        },
        {
            "location": "/Metadata/#metadata-api",
            "text": "",
            "title": "Metadata API"
        },
        {
            "location": "/Metadata/#class-for-working-with-crimson-hexagon-account-and-analysis-metadata",
            "text": "",
            "title": "Class for working with Crimson Hexagon account and analysis metadata."
        },
        {
            "location": "/Metadata/#example-usage",
            "text": ">>> from hexpy import HexpySession, MetadataAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> metadata_client = MetadataAPI(session)\n>>> metadata_client.team_list()\n>>> session.close()",
            "title": "Example usage."
        },
        {
            "location": "/Metadata/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/Metadata/#team_list",
            "text": "team_list()  Return a list of teams accessible to the requesting user.",
            "title": "team_list"
        },
        {
            "location": "/Metadata/#monitor_list",
            "text": "monitor_list(team_id)  Returns a list of monitors accessible to the requesting or selected user along with metadata related to those monitors.",
            "title": "monitor_list"
        },
        {
            "location": "/Metadata/#arguments",
            "text": "team_id: integer id number for a team",
            "title": "Arguments"
        },
        {
            "location": "/Metadata/#geography",
            "text": "geography()  Return all the geographical locations that you may use to filter monitor results and to upload documents with location information.",
            "title": "geography"
        },
        {
            "location": "/Metadata/#states",
            "text": "states(country)  Return all the states for a given country that you may use to filter monitor results and to upload documents with location information.",
            "title": "states"
        },
        {
            "location": "/Metadata/#arguments_1",
            "text": "country: country code to filter states",
            "title": "Arguments"
        },
        {
            "location": "/Metadata/#cities",
            "text": "cities(country)  Returns all the cities or urban areas defined in the given country that you may use to filter monitor results and to upload documents with location information.",
            "title": "cities"
        },
        {
            "location": "/Metadata/#arguments_2",
            "text": "country: country: country code  to filter states",
            "title": "Arguments"
        },
        {
            "location": "/Metadata/#countries",
            "text": "countries()  Returns all the countries that you may use to filter monitor results and to upload documents with location information.",
            "title": "countries"
        },
        {
            "location": "/Monitor/",
            "text": "Monitor API\n\n\nClass for working with Crimson Hexagon Monitor API.\n\n\nExample usage.\n\n\n>>> from hexpy import HexpySession, MonitorAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> monitor_client = MonitorAPI(session)\n>>> details = monitor_client.details(monitor_id)\n>>> start = details[\"resultsStart\"]\n>>> end = details[\"resultsEnd\"]\n>>> monitor_client.posts(monitor_id, start, end)\n>>> session.close()\n\n\n\n\nMethods\n\n\ndetails\n\n\ndetails(monitor_id)\n\n\n\n\nReturn detailed metadata about the selected monitor, including category metadata.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\n\n\naudit\n\n\naudit(monitor_id)\n\n\n\n\nReturn audit information about the selected monitor, sorted from most to least recent.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\n\n\nword_cloud\n\n\nword_cloud(monitor_id, start, end, filter_string=None)\n\n\n\n\nReturn an alphabetized list of the top 300 words in a monitor. This data is generated using documents randomly selected from the pool defined by the submitted parameters.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\nfilter_string: String, pipe-separated list of field:value pairs used to filter posts\n\n\n\n\ntrained_posts\n\n\ntrained_posts(monitor_id, category=None)\n\n\n\n\nReturn a list of the training posts for a given opinion monitor. The selected monitor must be an opinion monitor; requests for other monitor types will return an error. By default, all training posts for all categories in a monitor will be returned, however you may pass a category ID in your request to get training posts from a specific category.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\ncategory: Integer, category id to target training posts from a specific category\n\n\n\n\ntrain_monitor\n\n\ntrain_monitor(monitor_id, category_id, data)\n\n\n\n\nUpload individual training document monitors programmatically.\n\n\nYou may only upload one document per request. Due to the restrictions involved in using this endpoint, unless you have a specific need to train monitors programmatically, training monitors via the user interface in ForSight will normally be the more efficient training option. \nReference\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\ncategory_id: Integer, the category this content should belong to\n\n\ndata: Dictionary, document item with required fields\n\n\n\n\ninterest_affinities\n\n\ninterest_affinities(monitor_id, start, end, daily=False, document_source=None)\n\n\n\n\nReturn information about the authors in a monitor and their affinity with a range of pre-defined topics.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\ndaily: Boolean, if true, results returned from this endpoint will be trended daily instead of aggregated across the selected date range\n\n\ndocument_source: String, document source for affinities. valid params include \nTWITTER\n or \nTUMBLR\n\n\n\n\ntop_sources\n\n\ntop_sources(monitor_id, start, end)\n\n\n\n\nReturn volume information related to the sites and content sources (e.g. Twitter, Forums, Blogs, etc.) in a monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\nimage_analysis\n\n\nimage_analysis(monitor_id, start, end, object_type=\"\", top=100)\n\n\n\n\nReturn a breakdown of the top image classes within a provided monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\nobject_type: String, specifies type of image classes, valid values [object, scene, action, logo]\n\n\ntop : Integer, if defined, only the selected number of classes will be returned\n\n\n\n\nvolume\n\n\nvolume(monitor_id, start, end, aggregate_by_day=False, use_local_time=False)\n\n\n\n\nReturn volume metrics for a given monitor split by date.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\naggregate_by_day: Boolean, if True, volume information will be aggregated by day of the week instead of time of day\n\n\nuse_local_time: if True, volume aggregation will use the time local to the publishing author of a post, instead of converting that time to the timezone of the selected monitor\n\n\n\n\nsentiment_and_categories\n\n\nsentiment_and_categories(monitor_id, start, end, hide_excluded=False)\n\n\n\n\nReturn aggregate volume, sentiment, emotion and opinion category analysis for a given monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\nhide_excluded: Boolean, if True, categories set as hidden will not be included in category proportion calculations.\n\n\n\n\naggregate\n\n\naggregate(monitor_ids, dates, metrics)\n\n\n\n\nReturn aggregated results for one or monitor ids, for one or more date pairs, for one or more metrics.\n\n\nValid metrics\n\n\n\n\n'volume'\n\n\n'word_cloud'\n\n\n'top_sources'\n\n\n'interest_affinities'\n\n\n'sentiment_and_categories'\n\n\n\n\nArguments\n\n\n\n\nmonitor_ids: Integer or list of Integers, id(s) of the monitor(s) being requested\n\n\ndates: Tuple of Strings or list of Tuples, pair(s) of 'YYYY-MM-DD' date strings\n\n\nmetrics: String or list of Strings, metric(s) to aggregate upon\n\n\n\n\nposts\n\n\nposts(monitor_id, start, end, filter_string=None, extend_limit=False, full_contents=False, geotagged=False)\n\n\n\n\nReturn post-level information (where available) and associated analysis (sentiment, emotion) for a given monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\nfilter_string: String, pipe-separated list of field:value pairs used to filter posts\n\n\nextend_limit: Boolean if True increase limit of returned posts from 500 per call to 10000 per call\n\n\nfull_contents: Boolean, if True, the contents field will return the original, complete posts contents instead of truncating around search terms\n\n\ngeotagged: Boolean, if True, returns only geotagged documents matching the given filter\n\n\n\n\nDemographics\n\n\nThis collection of endpoints provide demographic volume metrics for users within a given monitor.\n\n\nage\n\n\nage(monitor_id, start, end)\n\n\n\n\nReturn volume metrics for a given monitor split by age bracket.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\nethnicity\n\n\nethnicity(monitor_id, start, end)\n\n\n\n\nReturn volume metrics for a given monitor split by ethnicity.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\ngender\n\n\ngender(monitor_id, start, end)\n\n\n\n\nReturn volume metrics for a given monitor split by gender.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\nGeography\n\n\ncities\n\n\ncities(monitor_id, start, end, country)\n\n\n\n\nReturn volume metrics for a given monitor split by city.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\ncountry: String, country code to filter cities\n\n\n\n\nstates\n\n\nstates(monitor_id, start, end, country)\n\n\n\n\nReturn volume metrics for a given monitor split by state.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\ncountry: String, country code to filter states\n\n\n\n\ncountries\n\n\ncountries(monitor_id, start, end)\n\n\n\n\nReturn volume metrics for a given monitor split by country.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\nTwitter\n\n\nThis collection of endpoints relate provide metrics specific to Twitter from either Social Account or Buzz monitors. \n\n\ntwitter_authors\n\n\ntwitter_authors(monitor_id, start, end)\n\n\n\n\nReturn information related to the Twitter authors who have posted in a given monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\ntwitter_metrics\n\n\ntwitter_metrics(monitor_id, start, end)\n\n\n\n\nReturn information about the top hashtags, mentions, and retweets in a monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\ntwitter_followers\n\n\ntwitter_followers(monitor_id, start, end)\n\n\n\n\nReturn the cumulative daily follower count for a targeted Twitter account in a Twitter Social Account Monitor as of the selected dates.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\ntwitter_sent_posts\n\n\ntwitter_sent_posts(monitor_id, start, end)\n\n\n\n\nReturn information about posts sent by the owner of a target Twitter account in a Twitter Social Account Monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\ntwitter_engagement\n\n\ntwitter_engagement(monitor_id, start, end):\n\n\n\n\nReturn information about retweets, replies, and @mentions for a Twitter Social Account monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\nFacebook\n\n\nfacebook_admin_posts\n\n\nfacebook_admin_posts(monitor_id, start, end)\n\n\n\n\nReturn those posts made by the administrators/owners of a targeted Facebook page in a Facebook Social Account Monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\nfacebook_likes\n\n\nfacebook_likes(monitor_id, start, end)\n\n\n\n\nReturn the cumulative daily like count for a targeted Facebook page in a Facebook Social Account Monitor as of the selected dates.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\nfacebook_activity\n\n\nfacebook_activity(monitor_id, start, end)\n\n\n\n\nReturn information about actions (likes, comments, shares) made by users and admins for a given page.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\nInstagram\n\n\ninstagram_top_hashtags\n\n\ninstagram_top_hashtags(monitor_id, start, end)\n\n\n\n\nReturn the Top 50 most occurring Hashtags contained within the posts analyzed in a monitor, plus all explicitly targeted hashtags in a monitor's query, for which Metrics are being collected (i.e. for which the hashtags are being tracked explicitly in ForSight).\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\ninstagram_followers\n\n\ninstagram_followers(monitor_id, start, end)\n\n\n\n\nReturn the cumulative daily follower count for a targeted Instagram account in an Instagram Social Account Monitor as of the selected dates.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\ninstagram_sent_media\n\n\ninstagram_sent_media(monitor_id, start, end)\n\n\n\n\nReturn media sent by admins in a targeted Instagram account.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD\n\n\n\n\ninstagram_activity\n\n\ninstagram_activity(monitor_id, start, end)\n\n\n\n\nReturn information about actions (likes, comments) made by users and admins for a given account.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, id of the monitor or monitor filter being requested\n\n\nstart: String, inclusive start date in YYYY-MM-DD\n\n\nend: String, exclusive end date in YYYY-MM-DD",
            "title": "Monitor"
        },
        {
            "location": "/Monitor/#monitor-api",
            "text": "",
            "title": "Monitor API"
        },
        {
            "location": "/Monitor/#class-for-working-with-crimson-hexagon-monitor-api",
            "text": "",
            "title": "Class for working with Crimson Hexagon Monitor API."
        },
        {
            "location": "/Monitor/#example-usage",
            "text": ">>> from hexpy import HexpySession, MonitorAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> monitor_client = MonitorAPI(session)\n>>> details = monitor_client.details(monitor_id)\n>>> start = details[\"resultsStart\"]\n>>> end = details[\"resultsEnd\"]\n>>> monitor_client.posts(monitor_id, start, end)\n>>> session.close()",
            "title": "Example usage."
        },
        {
            "location": "/Monitor/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/Monitor/#details",
            "text": "details(monitor_id)  Return detailed metadata about the selected monitor, including category metadata.",
            "title": "details"
        },
        {
            "location": "/Monitor/#arguments",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#audit",
            "text": "audit(monitor_id)  Return audit information about the selected monitor, sorted from most to least recent.",
            "title": "audit"
        },
        {
            "location": "/Monitor/#arguments_1",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#word_cloud",
            "text": "word_cloud(monitor_id, start, end, filter_string=None)  Return an alphabetized list of the top 300 words in a monitor. This data is generated using documents randomly selected from the pool defined by the submitted parameters.",
            "title": "word_cloud"
        },
        {
            "location": "/Monitor/#arguments_2",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD  filter_string: String, pipe-separated list of field:value pairs used to filter posts",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#trained_posts",
            "text": "trained_posts(monitor_id, category=None)  Return a list of the training posts for a given opinion monitor. The selected monitor must be an opinion monitor; requests for other monitor types will return an error. By default, all training posts for all categories in a monitor will be returned, however you may pass a category ID in your request to get training posts from a specific category.",
            "title": "trained_posts"
        },
        {
            "location": "/Monitor/#arguments_3",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  category: Integer, category id to target training posts from a specific category",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#train_monitor",
            "text": "train_monitor(monitor_id, category_id, data)  Upload individual training document monitors programmatically.  You may only upload one document per request. Due to the restrictions involved in using this endpoint, unless you have a specific need to train monitors programmatically, training monitors via the user interface in ForSight will normally be the more efficient training option.  Reference",
            "title": "train_monitor"
        },
        {
            "location": "/Monitor/#arguments_4",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  category_id: Integer, the category this content should belong to  data: Dictionary, document item with required fields",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#interest_affinities",
            "text": "interest_affinities(monitor_id, start, end, daily=False, document_source=None)  Return information about the authors in a monitor and their affinity with a range of pre-defined topics.",
            "title": "interest_affinities"
        },
        {
            "location": "/Monitor/#arguments_5",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD  daily: Boolean, if true, results returned from this endpoint will be trended daily instead of aggregated across the selected date range  document_source: String, document source for affinities. valid params include  TWITTER  or  TUMBLR",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#top_sources",
            "text": "top_sources(monitor_id, start, end)  Return volume information related to the sites and content sources (e.g. Twitter, Forums, Blogs, etc.) in a monitor.",
            "title": "top_sources"
        },
        {
            "location": "/Monitor/#arguments_6",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#image_analysis",
            "text": "image_analysis(monitor_id, start, end, object_type=\"\", top=100)  Return a breakdown of the top image classes within a provided monitor.",
            "title": "image_analysis"
        },
        {
            "location": "/Monitor/#arguments_7",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD  object_type: String, specifies type of image classes, valid values [object, scene, action, logo]  top : Integer, if defined, only the selected number of classes will be returned",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#volume",
            "text": "volume(monitor_id, start, end, aggregate_by_day=False, use_local_time=False)  Return volume metrics for a given monitor split by date.",
            "title": "volume"
        },
        {
            "location": "/Monitor/#arguments_8",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD  aggregate_by_day: Boolean, if True, volume information will be aggregated by day of the week instead of time of day  use_local_time: if True, volume aggregation will use the time local to the publishing author of a post, instead of converting that time to the timezone of the selected monitor",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#sentiment_and_categories",
            "text": "sentiment_and_categories(monitor_id, start, end, hide_excluded=False)  Return aggregate volume, sentiment, emotion and opinion category analysis for a given monitor.",
            "title": "sentiment_and_categories"
        },
        {
            "location": "/Monitor/#arguments_9",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD  hide_excluded: Boolean, if True, categories set as hidden will not be included in category proportion calculations.",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#aggregate",
            "text": "aggregate(monitor_ids, dates, metrics)  Return aggregated results for one or monitor ids, for one or more date pairs, for one or more metrics.",
            "title": "aggregate"
        },
        {
            "location": "/Monitor/#valid-metrics",
            "text": "'volume'  'word_cloud'  'top_sources'  'interest_affinities'  'sentiment_and_categories'",
            "title": "Valid metrics"
        },
        {
            "location": "/Monitor/#arguments_10",
            "text": "monitor_ids: Integer or list of Integers, id(s) of the monitor(s) being requested  dates: Tuple of Strings or list of Tuples, pair(s) of 'YYYY-MM-DD' date strings  metrics: String or list of Strings, metric(s) to aggregate upon",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#posts",
            "text": "posts(monitor_id, start, end, filter_string=None, extend_limit=False, full_contents=False, geotagged=False)  Return post-level information (where available) and associated analysis (sentiment, emotion) for a given monitor.",
            "title": "posts"
        },
        {
            "location": "/Monitor/#arguments_11",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD  filter_string: String, pipe-separated list of field:value pairs used to filter posts  extend_limit: Boolean if True increase limit of returned posts from 500 per call to 10000 per call  full_contents: Boolean, if True, the contents field will return the original, complete posts contents instead of truncating around search terms  geotagged: Boolean, if True, returns only geotagged documents matching the given filter",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#demographics",
            "text": "This collection of endpoints provide demographic volume metrics for users within a given monitor.",
            "title": "Demographics"
        },
        {
            "location": "/Monitor/#age",
            "text": "age(monitor_id, start, end)  Return volume metrics for a given monitor split by age bracket.",
            "title": "age"
        },
        {
            "location": "/Monitor/#arguments_12",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#ethnicity",
            "text": "ethnicity(monitor_id, start, end)  Return volume metrics for a given monitor split by ethnicity.",
            "title": "ethnicity"
        },
        {
            "location": "/Monitor/#arguments_13",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#gender",
            "text": "gender(monitor_id, start, end)  Return volume metrics for a given monitor split by gender.",
            "title": "gender"
        },
        {
            "location": "/Monitor/#arguments_14",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#geography",
            "text": "",
            "title": "Geography"
        },
        {
            "location": "/Monitor/#cities",
            "text": "cities(monitor_id, start, end, country)  Return volume metrics for a given monitor split by city.",
            "title": "cities"
        },
        {
            "location": "/Monitor/#arguments_15",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD  country: String, country code to filter cities",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#states",
            "text": "states(monitor_id, start, end, country)  Return volume metrics for a given monitor split by state.",
            "title": "states"
        },
        {
            "location": "/Monitor/#arguments_16",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD  country: String, country code to filter states",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#countries",
            "text": "countries(monitor_id, start, end)  Return volume metrics for a given monitor split by country.",
            "title": "countries"
        },
        {
            "location": "/Monitor/#arguments_17",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#twitter",
            "text": "This collection of endpoints relate provide metrics specific to Twitter from either Social Account or Buzz monitors.",
            "title": "Twitter"
        },
        {
            "location": "/Monitor/#twitter_authors",
            "text": "twitter_authors(monitor_id, start, end)  Return information related to the Twitter authors who have posted in a given monitor.",
            "title": "twitter_authors"
        },
        {
            "location": "/Monitor/#arguments_18",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#twitter_metrics",
            "text": "twitter_metrics(monitor_id, start, end)  Return information about the top hashtags, mentions, and retweets in a monitor.",
            "title": "twitter_metrics"
        },
        {
            "location": "/Monitor/#arguments_19",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#twitter_followers",
            "text": "twitter_followers(monitor_id, start, end)  Return the cumulative daily follower count for a targeted Twitter account in a Twitter Social Account Monitor as of the selected dates.",
            "title": "twitter_followers"
        },
        {
            "location": "/Monitor/#arguments_20",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#twitter_sent_posts",
            "text": "twitter_sent_posts(monitor_id, start, end)  Return information about posts sent by the owner of a target Twitter account in a Twitter Social Account Monitor.",
            "title": "twitter_sent_posts"
        },
        {
            "location": "/Monitor/#arguments_21",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#twitter_engagement",
            "text": "twitter_engagement(monitor_id, start, end):  Return information about retweets, replies, and @mentions for a Twitter Social Account monitor.",
            "title": "twitter_engagement"
        },
        {
            "location": "/Monitor/#arguments_22",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#facebook",
            "text": "",
            "title": "Facebook"
        },
        {
            "location": "/Monitor/#facebook_admin_posts",
            "text": "facebook_admin_posts(monitor_id, start, end)  Return those posts made by the administrators/owners of a targeted Facebook page in a Facebook Social Account Monitor.",
            "title": "facebook_admin_posts"
        },
        {
            "location": "/Monitor/#arguments_23",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#facebook_likes",
            "text": "facebook_likes(monitor_id, start, end)  Return the cumulative daily like count for a targeted Facebook page in a Facebook Social Account Monitor as of the selected dates.",
            "title": "facebook_likes"
        },
        {
            "location": "/Monitor/#arguments_24",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#facebook_activity",
            "text": "facebook_activity(monitor_id, start, end)  Return information about actions (likes, comments, shares) made by users and admins for a given page.",
            "title": "facebook_activity"
        },
        {
            "location": "/Monitor/#arguments_25",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#instagram",
            "text": "",
            "title": "Instagram"
        },
        {
            "location": "/Monitor/#instagram_top_hashtags",
            "text": "instagram_top_hashtags(monitor_id, start, end)  Return the Top 50 most occurring Hashtags contained within the posts analyzed in a monitor, plus all explicitly targeted hashtags in a monitor's query, for which Metrics are being collected (i.e. for which the hashtags are being tracked explicitly in ForSight).",
            "title": "instagram_top_hashtags"
        },
        {
            "location": "/Monitor/#arguments_26",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#instagram_followers",
            "text": "instagram_followers(monitor_id, start, end)  Return the cumulative daily follower count for a targeted Instagram account in an Instagram Social Account Monitor as of the selected dates.",
            "title": "instagram_followers"
        },
        {
            "location": "/Monitor/#arguments_27",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#instagram_sent_media",
            "text": "instagram_sent_media(monitor_id, start, end)  Return media sent by admins in a targeted Instagram account.",
            "title": "instagram_sent_media"
        },
        {
            "location": "/Monitor/#arguments_28",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Monitor/#instagram_activity",
            "text": "instagram_activity(monitor_id, start, end)  Return information about actions (likes, comments) made by users and admins for a given account.",
            "title": "instagram_activity"
        },
        {
            "location": "/Monitor/#arguments_29",
            "text": "monitor_id: Integer, id of the monitor or monitor filter being requested  start: String, inclusive start date in YYYY-MM-DD  end: String, exclusive end date in YYYY-MM-DD",
            "title": "Arguments"
        },
        {
            "location": "/Analysis/",
            "text": "Analysis API\n\n\nClass for working with Crimson Hexagon Analysis API.\n\n\nExample Usage\n\n\n>>> from hexpy import HexpySession, AnalysisAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> analysis_client = AnalysisAPI(session)\n>>> analysis_client.results(request_id)\n>>> session.close()\n\n\n\n\nMethods\n\n\nanaysis_requests\n\n\nanalysis_request(data)\n\n\n\n\nSubmit a query task against 24 hours of social data.\n\n\nArguments\n\n\n\n\ndata: Dictionary, query and filter parameters\n\n\n\n\nresults\n\n\nresults(request_id)\n\n\n\n\nRetrieve the status of the analysis request and the results.\n\n\nArguments\n\n\n\n\nrequest_id: Integer, the identifier given for the analysis, generated via the Analysis Request endpoints",
            "title": "Analysis"
        },
        {
            "location": "/Analysis/#analysis-api",
            "text": "",
            "title": "Analysis API"
        },
        {
            "location": "/Analysis/#class-for-working-with-crimson-hexagon-analysis-api",
            "text": "",
            "title": "Class for working with Crimson Hexagon Analysis API."
        },
        {
            "location": "/Analysis/#example-usage",
            "text": ">>> from hexpy import HexpySession, AnalysisAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> analysis_client = AnalysisAPI(session)\n>>> analysis_client.results(request_id)\n>>> session.close()",
            "title": "Example Usage"
        },
        {
            "location": "/Analysis/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/Analysis/#anaysis_requests",
            "text": "analysis_request(data)  Submit a query task against 24 hours of social data.",
            "title": "anaysis_requests"
        },
        {
            "location": "/Analysis/#arguments",
            "text": "data: Dictionary, query and filter parameters",
            "title": "Arguments"
        },
        {
            "location": "/Analysis/#results",
            "text": "results(request_id)  Retrieve the status of the analysis request and the results.",
            "title": "results"
        },
        {
            "location": "/Analysis/#arguments_1",
            "text": "request_id: Integer, the identifier given for the analysis, generated via the Analysis Request endpoints",
            "title": "Arguments"
        },
        {
            "location": "/Upload/",
            "text": "Upload API\n\n\nClass for working with Content Upload API.\n\n\nYou may use the Content Upload endpoint to upload documents for analysis.\nIn the past, users have uploaded survey responses, proprietary content,\nand other types of data not available in the Crimson Hexagon data library.\nTo use this endpoint, please contact support and they will create a new custom content type for you. \nReference\n\n\nExample Usage\n\n\n>>> from hexpy import HexpySession, ContentUploadAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> upload_client = ContentUploadAPI(session)\n>>> items = [\n    {\n      \"title\": \"Example Title\",\n      \"date\": \"2010-01-26T16:14:00\",\n      \"author\": \"me\",\n      \"url\": \"http://www.crimsonhexagon.com/post1\",\n      \"contents\": \"Example content\",\n      \"language\": \"en\",\n      \"type\": \"Your_Assigned_Content_Type_Name\",\n      \"geolocation\": {\n        \"id\": \"USA.NY\"\n      }\n    },\n  ]\n>>> upload_client.upload(items)\n>>> session.close()\n\n\n\n\nMethods\n\n\nupload\n\n\nupload(data)\n\n\n\n\nUpload list of document dictionaries to Crimson Hexagon platform.\n\n\nIf greater than 1000 items passed, reverts to batch upload.\n\n\nArguments\n\n\n\n\ndata: list of document dictionaries  to upload.\n\n\n\n\nbatch_upload\n\n\nbatch_upload(data)\n\n\n\n\nBatch upload list of document dictionaries to Crimson Hexagon platform.\n\n\nArguments\n\n\n\n\ndata: list of document dictionaries to upload in batches of 1000.",
            "title": "Upload"
        },
        {
            "location": "/Upload/#upload-api",
            "text": "",
            "title": "Upload API"
        },
        {
            "location": "/Upload/#class-for-working-with-content-upload-api",
            "text": "You may use the Content Upload endpoint to upload documents for analysis.\nIn the past, users have uploaded survey responses, proprietary content,\nand other types of data not available in the Crimson Hexagon data library.\nTo use this endpoint, please contact support and they will create a new custom content type for you.  Reference",
            "title": "Class for working with Content Upload API."
        },
        {
            "location": "/Upload/#example-usage",
            "text": ">>> from hexpy import HexpySession, ContentUploadAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> upload_client = ContentUploadAPI(session)\n>>> items = [\n    {\n      \"title\": \"Example Title\",\n      \"date\": \"2010-01-26T16:14:00\",\n      \"author\": \"me\",\n      \"url\": \"http://www.crimsonhexagon.com/post1\",\n      \"contents\": \"Example content\",\n      \"language\": \"en\",\n      \"type\": \"Your_Assigned_Content_Type_Name\",\n      \"geolocation\": {\n        \"id\": \"USA.NY\"\n      }\n    },\n  ]\n>>> upload_client.upload(items)\n>>> session.close()",
            "title": "Example Usage"
        },
        {
            "location": "/Upload/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/Upload/#upload",
            "text": "upload(data)  Upload list of document dictionaries to Crimson Hexagon platform.  If greater than 1000 items passed, reverts to batch upload.",
            "title": "upload"
        },
        {
            "location": "/Upload/#arguments",
            "text": "data: list of document dictionaries  to upload.",
            "title": "Arguments"
        },
        {
            "location": "/Upload/#batch_upload",
            "text": "batch_upload(data)  Batch upload list of document dictionaries to Crimson Hexagon platform.",
            "title": "batch_upload"
        },
        {
            "location": "/Upload/#arguments_1",
            "text": "data: list of document dictionaries to upload in batches of 1000.",
            "title": "Arguments"
        },
        {
            "location": "/Streams/",
            "text": "Streams API\n\n\nClass for working with Streams API.\n\n\nExample usage.\n\n\n>>> from hexpy import HexpySession , StreamsAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> streams_client = StreamsAPI(session)\n>>> streams_client.stream_list(team_id)\n>>> session.close()\n\n\n\n\nMethods\n\n\nposts\n\n\nposts(stream_id, count=100)\n\n\n\n\nReturn posts from a stream.\n\n\nArguments:\n\n\n\n\nstream_id: Integer, the id of the stream containing the posts.\n\n\ncount: Integer, the count of posts to retrieve from the stream, max = 100.\n\n\n\n\nstream_list\n\n\nstream_list(team_id)\n\n\n\n\nList all available Streams for a team.\n\n\nArguments\n\n\n\n\nteam_id: Integer the id of the team.\n\n\n\n\ncreate_stream\n\n\ncreate_stream(team_id, name)\n\n\n\n\nCreate new stream for a team. System Admin Only.\n\n\nArguments\n\n\n\n\nteam_id: Integer, the id of the team to associate created stream with.\n\n\nname: String, the name to associate with the newly created stream.\n\n\n\n\ndelete_stream\n\n\ndelete_stream(stream_id)\n\n\n\n\nDelete a stream. System Admin Only.\n\n\nArguments\n\n\n\n\nstream_id: Integer, the id of the stream to be deleted.\n\n\n\n\nadd_monitor_to_stream\n\n\nadd_monitor_to_stream(stream_id, monitor_id)\n\n\n\n\nAssociate a monitor with a stream. System Admin Only.\n\n\nArguments\n\n\n\n\nstream_id: Integer, the id of stream to be modified.\n\n\nmonitor_id: Integer, the id to be associated with the stream.\n\n\n\n\nremove_monitor_from_stream\n\n\nremove_monitor_from_stream(stream_id, monitor_id)\n\n\n\n\nRemove association between monitor and stream.  System Admin Only.\n\n\nArguments\n\n\n\n\nstream_id: Integer, the id of stream to be updated.\n\n\nmonitor_id: Integer, the id to be removed from the stream.\n\n\n\n\nupdate_stream\n\n\nupdate_stream(stream_id, name)\n\n\n\n\nUpdate name of stream. System Admin Only.\n\n\nArguments\n\n\n\n\nstream_id: Integer, the id of stream to be updated.\n\n\nname: String, the new name to be associated with the stream.",
            "title": "Streams"
        },
        {
            "location": "/Streams/#streams-api",
            "text": "",
            "title": "Streams API"
        },
        {
            "location": "/Streams/#class-for-working-with-streams-api",
            "text": "",
            "title": "Class for working with Streams API."
        },
        {
            "location": "/Streams/#example-usage",
            "text": ">>> from hexpy import HexpySession , StreamsAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> streams_client = StreamsAPI(session)\n>>> streams_client.stream_list(team_id)\n>>> session.close()",
            "title": "Example usage."
        },
        {
            "location": "/Streams/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/Streams/#posts",
            "text": "posts(stream_id, count=100)  Return posts from a stream.",
            "title": "posts"
        },
        {
            "location": "/Streams/#arguments",
            "text": "stream_id: Integer, the id of the stream containing the posts.  count: Integer, the count of posts to retrieve from the stream, max = 100.",
            "title": "Arguments:"
        },
        {
            "location": "/Streams/#stream_list",
            "text": "stream_list(team_id)  List all available Streams for a team.",
            "title": "stream_list"
        },
        {
            "location": "/Streams/#arguments_1",
            "text": "team_id: Integer the id of the team.",
            "title": "Arguments"
        },
        {
            "location": "/Streams/#create_stream",
            "text": "create_stream(team_id, name)  Create new stream for a team. System Admin Only.",
            "title": "create_stream"
        },
        {
            "location": "/Streams/#arguments_2",
            "text": "team_id: Integer, the id of the team to associate created stream with.  name: String, the name to associate with the newly created stream.",
            "title": "Arguments"
        },
        {
            "location": "/Streams/#delete_stream",
            "text": "delete_stream(stream_id)  Delete a stream. System Admin Only.",
            "title": "delete_stream"
        },
        {
            "location": "/Streams/#arguments_3",
            "text": "stream_id: Integer, the id of the stream to be deleted.",
            "title": "Arguments"
        },
        {
            "location": "/Streams/#add_monitor_to_stream",
            "text": "add_monitor_to_stream(stream_id, monitor_id)  Associate a monitor with a stream. System Admin Only.",
            "title": "add_monitor_to_stream"
        },
        {
            "location": "/Streams/#arguments_4",
            "text": "stream_id: Integer, the id of stream to be modified.  monitor_id: Integer, the id to be associated with the stream.",
            "title": "Arguments"
        },
        {
            "location": "/Streams/#remove_monitor_from_stream",
            "text": "remove_monitor_from_stream(stream_id, monitor_id)  Remove association between monitor and stream.  System Admin Only.",
            "title": "remove_monitor_from_stream"
        },
        {
            "location": "/Streams/#arguments_5",
            "text": "stream_id: Integer, the id of stream to be updated.  monitor_id: Integer, the id to be removed from the stream.",
            "title": "Arguments"
        },
        {
            "location": "/Streams/#update_stream",
            "text": "update_stream(stream_id, name)  Update name of stream. System Admin Only.",
            "title": "update_stream"
        },
        {
            "location": "/Streams/#arguments_6",
            "text": "stream_id: Integer, the id of stream to be updated.  name: String, the new name to be associated with the stream.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/",
            "text": "Realtime API\n\n\nClass for working with Realtime Results API.\n\n\nExample usage.\n\n\n>>> from hexpy import HexpySession, RealtimeAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> realtime_client = RealtimeAPI(session)\n>>> realtime_client.list(team_id)\n>>> session.close()\n\n\n\n\nMethods\n\n\nlist\n\n\nlist(team_id)\n\n\n\n\nGet the Monitors which are in Proteus\n\n\nArguments\n\n\n\n\nteam_id: Integer, The id of the team to which the listed monitors belong.\n\n\n\n\nconfigure\n\n\nconfigure(monitor_id)\n\n\n\n\nConfigure the Realtime evaluators for the Monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, the id of the monitor being requested.\n\n\n\n\nenable\n\n\nenable(monitor_id)\n\n\n\n\nEnable Realtime Data.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, the id of the monitor being requested.\n\n\n\n\ndisbale\n\n\ndisbale(monitor_id)\n\n\n\n\nDisable Realtime Data.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, the id of the monitor being requested.\n\n\n\n\ndetail\n\n\ndetail(monitor_id)\n\n\n\n\nGet the Realtime evaluators details for the Monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, the id of the monitor being requested.\n\n\n\n\ncashtags\n\n\ncashtags(monitor_id, start, top)\n\n\n\n\nGet Cashtags associated to a Monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, the id of the monitor being requested.\n\n\nstart: Integer, specifies inclusive start date in epoch seconds.\n\n\ntop: Integer, The top N cashtags to retrieve.\n\n\n\n\nhashtags\n\n\nhashtags(monitor_id, start, top)\n\n\n\n\nGet Hashtags associated to a Monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, the id of the monitor being requested.\n\n\nstart: Integer, specifies inclusive start date in epoch seconds.\n\n\ntop: Integer, The top N hashtags to retrieve.\n\n\n\n\nretweets\n\n\nretweets(monitor_id)\n\n\n\n\nGet the Realtime retweets for the Monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, the id of the monitor being requested.\n\n\n\n\nsocial_guids\n\n\nsocial_guids(monitor_id, doc_type, start, received_after) \n\n\n\n\nGet the Realtime social guids for the Monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, the id of the monitor being requested.\n\n\nstart: Integer, specifies inclusive start date in epoch seconds.\n\n\ntype: String, Specifies the document type.\n\n\n\n\ntweets\n\n\ntweets(monitor_id, start) \n\n\n\n\nGet the Realtime tweets for the Monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, the id of the monitor being requested.\n\n\nstart: Integer, specifies inclusive start date in epoch seconds.\n\n\n\n\nvolume\n\n\nvolume(monitor_id, doc_type, start) \n\n\n\n\nGet the Realtime volume for the Monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, the id of the monitor being requested.\n\n\nstart: Integer, specifies inclusive start date in epoch seconds.\n\n\ntype: List, specifies the document type to filter.\n\n\n\n\nvolume_by_sentiment\n\n\nvolume_by_sentiment(monitor_id, doc_type, start) \n\n\n\n\nGet the Realtime volume by sentiment for the Monitor.\n\n\nArguments\n\n\n\n\nmonitor_id: Integer, the id of the monitor being requested.\n\n\nstart: Integer, specifies inclusive start date in epoch seconds.\n\n\ntype: String, specifies the document type to filter.",
            "title": "Realtime"
        },
        {
            "location": "/Realtime/#realtime-api",
            "text": "",
            "title": "Realtime API"
        },
        {
            "location": "/Realtime/#class-for-working-with-realtime-results-api",
            "text": "",
            "title": "Class for working with Realtime Results API."
        },
        {
            "location": "/Realtime/#example-usage",
            "text": ">>> from hexpy import HexpySession, RealtimeAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> realtime_client = RealtimeAPI(session)\n>>> realtime_client.list(team_id)\n>>> session.close()",
            "title": "Example usage."
        },
        {
            "location": "/Realtime/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/Realtime/#list",
            "text": "list(team_id)  Get the Monitors which are in Proteus",
            "title": "list"
        },
        {
            "location": "/Realtime/#arguments",
            "text": "team_id: Integer, The id of the team to which the listed monitors belong.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/#configure",
            "text": "configure(monitor_id)  Configure the Realtime evaluators for the Monitor.",
            "title": "configure"
        },
        {
            "location": "/Realtime/#arguments_1",
            "text": "monitor_id: Integer, the id of the monitor being requested.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/#enable",
            "text": "enable(monitor_id)  Enable Realtime Data.",
            "title": "enable"
        },
        {
            "location": "/Realtime/#arguments_2",
            "text": "monitor_id: Integer, the id of the monitor being requested.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/#disbale",
            "text": "disbale(monitor_id)  Disable Realtime Data.",
            "title": "disbale"
        },
        {
            "location": "/Realtime/#arguments_3",
            "text": "monitor_id: Integer, the id of the monitor being requested.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/#detail",
            "text": "detail(monitor_id)  Get the Realtime evaluators details for the Monitor.",
            "title": "detail"
        },
        {
            "location": "/Realtime/#arguments_4",
            "text": "monitor_id: Integer, the id of the monitor being requested.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/#cashtags",
            "text": "cashtags(monitor_id, start, top)  Get Cashtags associated to a Monitor.",
            "title": "cashtags"
        },
        {
            "location": "/Realtime/#arguments_5",
            "text": "monitor_id: Integer, the id of the monitor being requested.  start: Integer, specifies inclusive start date in epoch seconds.  top: Integer, The top N cashtags to retrieve.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/#hashtags",
            "text": "hashtags(monitor_id, start, top)  Get Hashtags associated to a Monitor.",
            "title": "hashtags"
        },
        {
            "location": "/Realtime/#arguments_6",
            "text": "monitor_id: Integer, the id of the monitor being requested.  start: Integer, specifies inclusive start date in epoch seconds.  top: Integer, The top N hashtags to retrieve.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/#retweets",
            "text": "retweets(monitor_id)  Get the Realtime retweets for the Monitor.",
            "title": "retweets"
        },
        {
            "location": "/Realtime/#arguments_7",
            "text": "monitor_id: Integer, the id of the monitor being requested.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/#social_guids",
            "text": "social_guids(monitor_id, doc_type, start, received_after)   Get the Realtime social guids for the Monitor.",
            "title": "social_guids"
        },
        {
            "location": "/Realtime/#arguments_8",
            "text": "monitor_id: Integer, the id of the monitor being requested.  start: Integer, specifies inclusive start date in epoch seconds.  type: String, Specifies the document type.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/#tweets",
            "text": "tweets(monitor_id, start)   Get the Realtime tweets for the Monitor.",
            "title": "tweets"
        },
        {
            "location": "/Realtime/#arguments_9",
            "text": "monitor_id: Integer, the id of the monitor being requested.  start: Integer, specifies inclusive start date in epoch seconds.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/#volume",
            "text": "volume(monitor_id, doc_type, start)   Get the Realtime volume for the Monitor.",
            "title": "volume"
        },
        {
            "location": "/Realtime/#arguments_10",
            "text": "monitor_id: Integer, the id of the monitor being requested.  start: Integer, specifies inclusive start date in epoch seconds.  type: List, specifies the document type to filter.",
            "title": "Arguments"
        },
        {
            "location": "/Realtime/#volume_by_sentiment",
            "text": "volume_by_sentiment(monitor_id, doc_type, start)   Get the Realtime volume by sentiment for the Monitor.",
            "title": "volume_by_sentiment"
        },
        {
            "location": "/Realtime/#arguments_11",
            "text": "monitor_id: Integer, the id of the monitor being requested.  start: Integer, specifies inclusive start date in epoch seconds.  type: String, specifies the document type to filter.",
            "title": "Arguments"
        },
        {
            "location": "/Custom/",
            "text": "Custom API\n\n\nClass for creating a custom API\n\n\nExample usage.\n\n\n>>> from hexpy import HexpySession , CustomAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> custom_client = CustomAPI(session, \"/some/endpoint/\")\n>>> custom_client.get(url_params=\"<url_param1>/path\", params={\"query_string_param\":some_value})\n>>> session.close()\n\n\n\n\nMethods\n\n\nget\n\n\nget(url_params, params=None)\n\n\n\n\nend get request using URL parameters and query-string parameters.\n\n\nArguments:\n\n\n\n\nurl_params: String, url params and endpoints concatenated.\n\n\nparams: Dict, querystring params.\n\n\n\n\npost\n\n\npost(url_params, params=None, data=None)\n\n\n\n\nSend post request using URL parameters and query-string parameters, and json data.\n\n\nArguments\n\n\n\n\nurl_params: String, url params and endpoints concatenated.\n\n\nparams: Dict, querystring params.\n\n\ndata: Dict, json data to post.\n\n\n\n\ndelete\n\n\ndelete(url_params, params=None)\n\n\n\n\nSend delete request using URL parameters and query-string parameters.\n\n\nArguments\n\n\n\n\nurl_params: String, url params and endpoints concatenated.\n\n\nparams: Dict, querystring params.",
            "title": "Custom"
        },
        {
            "location": "/Custom/#custom-api",
            "text": "",
            "title": "Custom API"
        },
        {
            "location": "/Custom/#class-for-creating-a-custom-api",
            "text": "",
            "title": "Class for creating a custom API"
        },
        {
            "location": "/Custom/#example-usage",
            "text": ">>> from hexpy import HexpySession , CustomAPI\n>>> session = HexpySession.load_auth_from_file()\n>>> custom_client = CustomAPI(session, \"/some/endpoint/\")\n>>> custom_client.get(url_params=\"<url_param1>/path\", params={\"query_string_param\":some_value})\n>>> session.close()",
            "title": "Example usage."
        },
        {
            "location": "/Custom/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/Custom/#get",
            "text": "get(url_params, params=None)  end get request using URL parameters and query-string parameters.",
            "title": "get"
        },
        {
            "location": "/Custom/#arguments",
            "text": "url_params: String, url params and endpoints concatenated.  params: Dict, querystring params.",
            "title": "Arguments:"
        },
        {
            "location": "/Custom/#post",
            "text": "post(url_params, params=None, data=None)  Send post request using URL parameters and query-string parameters, and json data.",
            "title": "post"
        },
        {
            "location": "/Custom/#arguments_1",
            "text": "url_params: String, url params and endpoints concatenated.  params: Dict, querystring params.  data: Dict, json data to post.",
            "title": "Arguments"
        },
        {
            "location": "/Custom/#delete",
            "text": "delete(url_params, params=None)  Send delete request using URL parameters and query-string parameters.",
            "title": "delete"
        },
        {
            "location": "/Custom/#arguments_2",
            "text": "url_params: String, url params and endpoints concatenated.  params: Dict, querystring params.",
            "title": "Arguments"
        },
        {
            "location": "/CLI/",
            "text": "Hexpy Command Line Interface\n\n\nhexpy\n comes with a console script for conveniently automating several common tasks\n\n\nHelpful Commands\n\n\n\n\nExport sample of monitor posts to a spreadsheet.\n\n\nEasily upload a spreadsheet as custom content for analysis in ForSight.\n\n\nQuickly get multiple metrics from monitor results as JSON. \n\n\nCompose powerful shell scripts with pipe-able commands such as \njq\n, and \nxargs\n.\n\n\n\n\nUsage\n\n\nBasic\n\n\n$ hexpy [OPTIONS] COMMAND [ARGS]...\n\n\n\n\nCommands\n\n\n\n\nexport\n  Save Monitor posts as spreadsheet.\n\n\nlogin\n   Get valid authorization from user.\n\n\nquery\n   Request 24 analysis for provided query.\n\n\nresults\n Get Monitor results for 1 or more metrics.\n\n\nupload\n  Upload spreadsheet file as custom content.\n\n\nmetadata\n Get Metadata for account team, monitors, and geography.\n\n\n\n\nSee how each \nhexpy\n command works by running \nhexpy COMMAND --help\n\n\nExamples\n\n\nLogin to Crimson API with you credentials\n\n\n$ hexpy login --force\nEnter username: username@email.com\nEnter password: ***********\n\u2714 Success!\n\n\n\n\nGet list of monitors for the users team\n\n\nhexpy metadata monitor_list --team_id TEAM_ID | jq -r '.monitors[] | .id'\n\n\n\n\nUpload CSV file as \nmy_custom_types\n with English language code and tab delimted columns.\n\n\n$ hexpy upload spredsheet.csv --content_type my_custom_type --language en --delimiter '\\t'\n\n\n\n\nGet word cloud and volume information from the monitor in the specified date range.\n\n\n$ hexpy results MONITOR_ID volume word_cloud --date_range 2017-01-01 2017-02-01\n\n\n\n\nGet CSV data with volume information for the monitor for each day using \njq\n\n\n$ hexpy results MONITOR_ID volume | jq -r '.results.volume.volumes[] | [.startDate, .numberOfDocuments] | @csv'\n\"2017-01-04T00:00:00\",74\n\"2017-01-05T00:00:00\",101\n\"2017-01-06T00:00:00\",67\n\"2017-01-07T00:00:00\",58\n\"2017-01-08T00:00:00\",64\n\"2017-01-09T00:00:00\",72\n\"2017-01-10T00:00:00\",92\n\"2017-01-11T00:00:00\",72\n\"2017-01-12T00:00:00\",133\n\"2017-01-13T00:00:00\",67\n...\n\n\n\n\nExport Monitor posts to excel file called \nmy_export.xlsx\n\n\n$ hexpy export MONITOR_ID --file_type excel --output my_export\n\n\n\n\nExport posts to excel for multiple monitors in parallel from a file containing a list of monitor ids\n\n\ncat ids.txt | xargs -n 1 -P 4 hexpy export -f excel",
            "title": "Command Line Interface"
        },
        {
            "location": "/CLI/#hexpy-command-line-interface",
            "text": "hexpy  comes with a console script for conveniently automating several common tasks",
            "title": "Hexpy Command Line Interface"
        },
        {
            "location": "/CLI/#helpful-commands",
            "text": "Export sample of monitor posts to a spreadsheet.  Easily upload a spreadsheet as custom content for analysis in ForSight.  Quickly get multiple metrics from monitor results as JSON.   Compose powerful shell scripts with pipe-able commands such as  jq , and  xargs .",
            "title": "Helpful Commands"
        },
        {
            "location": "/CLI/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/CLI/#basic",
            "text": "$ hexpy [OPTIONS] COMMAND [ARGS]...",
            "title": "Basic"
        },
        {
            "location": "/CLI/#commands",
            "text": "export   Save Monitor posts as spreadsheet.  login    Get valid authorization from user.  query    Request 24 analysis for provided query.  results  Get Monitor results for 1 or more metrics.  upload   Upload spreadsheet file as custom content.  metadata  Get Metadata for account team, monitors, and geography.   See how each  hexpy  command works by running  hexpy COMMAND --help",
            "title": "Commands"
        },
        {
            "location": "/CLI/#examples",
            "text": "Login to Crimson API with you credentials  $ hexpy login --force\nEnter username: username@email.com\nEnter password: ***********\n\u2714 Success!  Get list of monitors for the users team  hexpy metadata monitor_list --team_id TEAM_ID | jq -r '.monitors[] | .id'  Upload CSV file as  my_custom_types  with English language code and tab delimted columns.  $ hexpy upload spredsheet.csv --content_type my_custom_type --language en --delimiter '\\t'  Get word cloud and volume information from the monitor in the specified date range.  $ hexpy results MONITOR_ID volume word_cloud --date_range 2017-01-01 2017-02-01  Get CSV data with volume information for the monitor for each day using  jq  $ hexpy results MONITOR_ID volume | jq -r '.results.volume.volumes[] | [.startDate, .numberOfDocuments] | @csv'\n\"2017-01-04T00:00:00\",74\n\"2017-01-05T00:00:00\",101\n\"2017-01-06T00:00:00\",67\n\"2017-01-07T00:00:00\",58\n\"2017-01-08T00:00:00\",64\n\"2017-01-09T00:00:00\",72\n\"2017-01-10T00:00:00\",92\n\"2017-01-11T00:00:00\",72\n\"2017-01-12T00:00:00\",133\n\"2017-01-13T00:00:00\",67\n...  Export Monitor posts to excel file called  my_export.xlsx  $ hexpy export MONITOR_ID --file_type excel --output my_export  Export posts to excel for multiple monitors in parallel from a file containing a list of monitor ids  cat ids.txt | xargs -n 1 -P 4 hexpy export -f excel",
            "title": "Examples"
        }
    ]
}